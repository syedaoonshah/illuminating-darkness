<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOE Calculator - Image Enhancement Quality Assessment</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .nav-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .nav-tab {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }

        .nav-tab.active {
            background: white;
            color: #4facfe;
            border-bottom: 3px solid #4facfe;
        }

        .nav-tab:hover:not(.active) {
            background: #e9ecef;
            color: #333;
        }

        .tab-content {
            display: none;
            padding: 40px;
        }

        .tab-content.active {
            display: block;
        }

        /* Single Image Mode Styles */
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .upload-box {
            border: 3px dashed #ddd;
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.3s ease;
            background: #fafafa;
            position: relative;
            overflow: hidden;
        }

        .upload-box:hover {
            border-color: #4facfe;
            background: #f0f9ff;
            transform: translateY(-2px);
        }

        .upload-box.dragover {
            border-color: #00f2fe;
            background: #e6f7ff;
            transform: scale(1.02);
        }

        .upload-box h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .upload-icon {
            font-size: 3rem;
            color: #4facfe;
            margin-bottom: 20px;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .upload-text {
            color: #666;
            font-size: 0.9rem;
        }

        .preview-container {
            margin-top: 20px;
            text-align: center;
        }

        .preview-image {
            max-width: 100%;
            max-height: 200px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .image-info {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #666;
        }

        /* Batch Processing Styles */
        .batch-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .control-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
        }

        .control-section h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.2rem;
        }

        .dataset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .method-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background: white;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .checkbox-item:hover {
            border-color: #4facfe;
            transform: translateY(-2px);
        }

        .checkbox-item.selected {
            border-color: #4facfe;
            background: #f0f9ff;
        }

        .checkbox-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .checkbox-item.disabled input[type="checkbox"] {
            cursor: not-allowed;
        }

        .checkbox-item.disabled label {
            cursor: not-allowed;
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
            accent-color: #4facfe;
        }

        .checkbox-item label {
            cursor: pointer;
            font-weight: 500;
            color: #333;
        }

        .calculate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }

        .calculate-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .calculate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .result-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            display: none;
            margin-bottom: 30px;
        }

        .result-section.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .loe-value {
            font-size: 3rem;
            font-weight: bold;
            color: #4facfe;
            margin-bottom: 10px;
            text-align: center;
        }

        .loe-interpretation {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 20px;
            text-align: center;
        }

        .batch-results-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            margin: 20px 0;
        }

        .batch-results-table th,
        .batch-results-table td {
            padding: 12px 8px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
            font-size: 0.9rem;
        }

        .batch-results-table th {
            background: #4facfe;
            color: white;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .batch-results-table th:first-child,
        .batch-results-table td:first-child {
            text-align: left;
            min-width: 120px;
        }

        .batch-results-table tr:hover {
            background: #f8f9fa;
        }

        .batch-results-table .metric-value {
            font-weight: 600;
            color: #2e7d32;
        }

        .batch-results-table .metric-value.na {
            color: #999;
            font-style: italic;
        }

        .batch-results-table .mean-row {
            background: #e3f2fd;
            font-weight: bold;
        }

        .batch-results-table .mean-row td {
            border-top: 2px solid #4facfe;
        }

        .processing {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .processing.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4facfe;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #666;
        }

        .image-gallery {
            margin-top: 30px;
        }

        .gallery-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .image-selector {
            padding: 10px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: white;
            font-size: 1rem;
            cursor: pointer;
        }

        .image-selector:focus {
            outline: none;
            border-color: #4facfe;
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            max-width: 100%;
        }

        .gallery-item {
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            min-width: 200px;
        }

        .gallery-item img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .gallery-item h4 {
            color: #333;
            margin-bottom: 5px;
            font-size: 0.95rem;
            word-wrap: break-word;
        }

        .gallery-item .loe-score {
            color: #4facfe;
            font-weight: bold;
            font-size: 1rem;
        }

        .info-section {
            background: #e3f2fd;
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
        }

        .info-section h3 {
            color: #1976d2;
            margin-bottom: 15px;
        }

        .info-section p {
            color: #666;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .upload-section, .batch-controls {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .tab-content {
                padding: 20px;
            }

            .nav-tab {
                padding: 15px 10px;
                font-size: 1rem;
            }

            .dataset-grid, .method-grid {
                grid-template-columns: 1fr;
            }

            .gallery-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Image Quality Assessment Suite</h1>
            <p>Multi-Metric Image Enhancement Quality Evaluation Platform</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="switchTab('single')">Single Image Mode</button>
            <button class="nav-tab" onclick="switchTab('batch')">Batch Processing</button>
        </div>

        <!-- Single Image Mode -->
        <div id="single-tab" class="tab-content active">
            <div class="upload-section">
                <div class="upload-box" id="inputUpload">
                    <div class="upload-icon">📷</div>
                    <h3>Input Image</h3>
                    <div class="upload-text">Drop your original image here or click to browse</div>
                    <input type="file" class="file-input" id="inputFile" accept="image/*">
                    <div class="preview-container" id="inputPreview"></div>
                </div>

                <div class="upload-box" id="enhancedUpload">
                    <div class="upload-icon">✨</div>
                    <h3>Enhanced Image</h3>
                    <div class="upload-text">Drop your enhanced image here or click to browse</div>
                    <input type="file" class="file-input" id="enhancedFile" accept="image/*">
                    <div class="preview-container" id="enhancedPreview"></div>
                </div>
            </div>

            <button class="calculate-btn" id="calculateBtn" disabled>Calculate Quality Metrics</button>

            <div class="processing" id="processing">
                <div class="spinner"></div>
                <p>Processing images and calculating LOE...</p>
            </div>

            <div class="result-section" id="resultSection">
                <div class="loe-value" id="loeValue">0.00</div>
                <div class="loe-interpretation" id="loeInterpretation">
                    Lower LOE values indicate better enhancement quality
                </div>
                <p><strong>Calculation completed!</strong> The LOE metric measures how well the enhanced image preserves the lightness order relationships of the original image.</p>
            </div>
        </div>

        <!-- Batch Processing Mode -->
        <div id="batch-tab" class="tab-content">
            <div class="batch-controls">
                <div class="control-section">
                    <h3>Select Datasets</h3>
                    <div class="dataset-grid" id="datasetGrid">
                        <!-- Dataset checkboxes will be populated by JavaScript -->
                    </div>
                </div>

                <div class="control-section">
                    <h3>Select Enhancement Methods</h3>
                    <div class="method-grid" id="methodGrid">
                        <!-- Method checkboxes will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <div class="control-section" style="margin-bottom: 30px;">
                <h3>Select Quality Metrics</h3>
                <div class="method-grid" id="metricGrid">
                    <!-- Quality metric checkboxes will be populated by JavaScript -->
                </div>
            </div>

            <button class="calculate-btn" id="batchCalculateBtn" disabled>Start Batch Processing</button>

            <div class="processing" id="batchProcessing">
                <div class="spinner"></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Initializing...</div>
            </div>

            <div class="result-section" id="batchResultSection">
                <h3>Batch Processing Results</h3>
                <div id="batchResultsContent"></div>
            </div>

            <div class="image-gallery" id="imageGallery" style="display: none;">
                <div class="gallery-controls">
                    <h3>Image Comparison Gallery</h3>
                    <select class="image-selector" id="imageSelector">
                        <option value="">Select an image to compare...</option>
                    </select>
                </div>
                <div class="gallery-grid" id="galleryGrid"></div>
            </div>
        </div>

        <div class="info-section">
            <h3>About Image Quality Assessment</h3>
            <p><strong>Multi-Metric Evaluation:</strong> This platform supports multiple quality assessment metrics to provide comprehensive evaluation of image enhancement algorithms.</p>
            
            <div style="margin: 20px 0;">
                <h4 style="color: #1976d2; margin-bottom: 10px;">🔍 No-Reference Metrics</h4>
                <p><strong>LOE (Lightness Order Error):</strong> Measures preservation of lightness order relationships between pixels.</p>
                <p><strong>NIQE (Natural Image Quality Evaluator):</strong> Evaluates naturalness based on scene statistics without requiring reference images.</p>
                <p><strong>BRISQUE:</strong> Blind quality assessment using natural scene statistics (Coming Soon).</p>
            </div>
            
            <div style="margin: 20px 0;">
                <h4 style="color: #1976d2; margin-bottom: 10px;">🔗 Full-Reference Metrics</h4>
                <p><strong>PSNR:</strong> Peak Signal-to-Noise Ratio measures signal fidelity (Coming Soon).</p>
                <p><strong>SSIM:</strong> Structural Similarity Index assesses structural similarity (Coming Soon).</p>
                <p><strong>LPIPS:</strong> Learned Perceptual Image Patch Similarity using deep learning (Coming Soon).</p>
            </div>
            
            <p><strong>Batch Processing:</strong> Upload datasets in the format: datasets/[DATASET]/inputs/ and datasets/[DATASET]/results/[METHOD]/ to enable automatic evaluation across multiple metrics.</p>
        </div>
    </div>

    <script>
        // Tab switching functionality - MUST be in global scope
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        // Dataset and method definitions
        const DATASETS = ['LOL', 'DICM', 'NPE', 'LIME', 'MEF'];
        const METHODS = [
            'CFWD', 'GSAD', 'Wave-Mamba', 'PyDiff', 'LYT-Net', 'Jin et al', 
            'HEP', 'SHAL-Net', 'AGLLDiff', 'LightenDiffusion', 'ZeroIG', 
            'RRDNet', 'SGZ', 'Zero-DCE++', 'Zero-DCE'
        ];

        // Available quality metrics
        const QUALITY_METRICS = [
            { 
                id: 'loe', 
                name: 'LOE', 
                fullName: 'Lightness Order Error',
                type: 'no-reference',
                lowerIsBetter: true,
                description: 'Measures preservation of lightness order relationships'
            },
            { 
                id: 'niqe', 
                name: 'NIQE', 
                fullName: 'Natural Image Quality Evaluator',
                type: 'no-reference',
                lowerIsBetter: true,
                description: 'Evaluates naturalness based on scene statistics'
            },
            { 
                id: 'psnr', 
                name: 'PSNR', 
                fullName: 'Peak Signal-to-Noise Ratio',
                type: 'full-reference',
                lowerIsBetter: false,
                description: 'Measures signal fidelity between images',
                disabled: true
            },
            { 
                id: 'ssim', 
                name: 'SSIM', 
                fullName: 'Structural Similarity Index',
                type: 'full-reference',
                lowerIsBetter: false,
                description: 'Assesses structural similarity between images',
                disabled: true
            },
            { 
                id: 'lpips', 
                name: 'LPIPS', 
                fullName: 'Learned Perceptual Image Patch Similarity',
                type: 'full-reference',
                lowerIsBetter: true,
                description: 'Deep learning-based perceptual similarity',
                disabled: true
            },
            { 
                id: 'dists', 
                name: 'DISTS', 
                fullName: 'Deep Image Structure and Texture Similarity',
                type: 'full-reference',
                lowerIsBetter: true,
                description: 'Structure and texture similarity using deep features',
                disabled: true
            },
            { 
                id: 'pieapp', 
                name: 'PieAPP', 
                fullName: 'Perceptual Image-Error Assessment through Pairwise Preference',
                type: 'full-reference',
                lowerIsBetter: true,
                description: 'Human preference-based quality assessment',
                disabled: true
            },
            { 
                id: 'brisque', 
                name: 'BRISQUE', 
                fullName: 'Blind/Referenceless Image Spatial Quality Evaluator',
                type: 'no-reference',
                lowerIsBetter: true,
                description: 'Blind quality assessment using natural scene statistics',
                disabled: true
            }
        ];

        class LOECalculator {
            constructor() {
                this.imageCache = new Map();
            }

            async calculateImageLOE(inputImage, enhancedImage) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const width = inputImage.width;
                const height = inputImage.height;
                
                canvas.width = width;
                canvas.height = height;
                
                ctx.drawImage(inputImage, 0, 0, width, height);
                const inputData = ctx.getImageData(0, 0, width, height);
                
                ctx.drawImage(enhancedImage, 0, 0, width, height);
                const enhancedData = ctx.getImageData(0, 0, width, height);
                
                return await this.computeLOE(inputData, enhancedData);
            }

            async loadImageFromPath(imagePath) {
                if (this.imageCache.has(imagePath)) {
                    return this.imageCache.get(imagePath);
                }

                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    const timeout = setTimeout(() => {
                        reject(new Error(`Timeout loading image: ${imagePath}`));
                    }, 10000);
                    
                    img.onload = () => {
                        clearTimeout(timeout);
                        this.imageCache.set(imagePath, img);
                        resolve(img);
                    };
                    
                    img.onerror = (error) => {
                        clearTimeout(timeout);
                        console.warn(`Failed to load image: ${imagePath}`, error);
                        resolve(null);
                    };
                    
                    img.src = imagePath;
                });
            }

            async computeLOE(inputData, enhancedData) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            const result = this.loeAlgorithm(inputData, enhancedData);
                            resolve(result);
                        } catch (error) {
                            console.error('Error in LOE algorithm:', error);
                            reject(error);
                        }
                    }, 100);
                });
            }

            loeAlgorithm(inputData, enhancedData) {
                const { width, height } = inputData;
                const m = height;
                const n = width;
                
                const win = 7;
                const inputGray = this.rgbToGray(inputData);
                const enhancedGray = this.rgbToGray(enhancedData);
                
                const imax = this.getLocalMax(inputGray, n, m, win);
                const emax = this.getLocalMax(enhancedGray, n, m, win);
                
                const blkwin = 50;
                const mind = Math.min(m, n);
                const step = Math.max(1, Math.floor(mind / blkwin));
                const blkm = Math.floor(m / step);
                const blkn = Math.floor(n / step);
                
                if (blkm <= 0 || blkn <= 0) {
                    throw new Error(`Invalid block dimensions: ${blkn}x${blkm}`);
                }
                
                const ipic_ds = [];
                const epic_ds = [];
                
                for (let i = 0; i < blkm; i++) {
                    ipic_ds[i] = [];
                    epic_ds[i] = [];
                    for (let j = 0; j < blkn; j++) {
                        const row = Math.min(i * step, m - 1);
                        const col = Math.min(j * step, n - 1);
                        ipic_ds[i][j] = imax[row][col];
                        epic_ds[i][j] = emax[row][col];
                    }
                }
                
                let totalLOE = 0;
                for (let i = 0; i < blkm; i++) {
                    for (let j = 0; j < blkn; j++) {
                        let loe = 0;
                        for (let p = 0; p < blkm; p++) {
                            for (let q = 0; q < blkn; q++) {
                                const flag1 = ipic_ds[p][q] >= ipic_ds[i][j];
                                const flag2 = epic_ds[p][q] >= epic_ds[i][j];
                                if (flag1 !== flag2) {
                                    loe++;
                                }
                            }
                        }
                        totalLOE += loe;
                    }
                }
                
                return totalLOE / (blkm * blkn);
            }

            rgbToGray(imageData) {
                const { data, width, height } = imageData;
                const gray = [];
                
                for (let i = 0; i < height; i++) {
                    gray[i] = [];
                    for (let j = 0; j < width; j++) {
                        const idx = (i * width + j) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        gray[i][j] = Math.max(r, g, b);
                    }
                }
                return gray;
            }

            getLocalMax(image, width, height, win) {
                const extImage = this.extendImage(image, width, height, win);
                const output = [];
                
                for (let i = 0; i < height; i++) {
                    output[i] = [];
                    for (let j = 0; j < width; j++) {
                        let max = 0;
                        for (let di = -win; di <= win; di++) {
                            for (let dj = -win; dj <= win; dj++) {
                                const extRow = i + win + di;
                                const extCol = j + win + dj;
                                if (extImage[extRow] && extImage[extRow][extCol] !== undefined) {
                                    const val = extImage[extRow][extCol];
                                    if (val > max) max = val;
                                }
                            }
                        }
                        output[i][j] = max;
                    }
                }
                return output;
            }

            extendImage(image, width, height, winSize) {
                const extended = [];
                const newHeight = height + 2 * winSize;
                const newWidth = width + 2 * winSize;
                
                for (let i = 0; i < newHeight; i++) {
                    extended[i] = new Array(newWidth).fill(0);
                }
                
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        extended[i + winSize][j + winSize] = image[i][j];
                    }
                }
                
                for (let i = 0; i < winSize; i++) {
                    for (let j = winSize; j < winSize + width; j++) {
                        extended[winSize - 1 - i][j] = extended[winSize + 1 + i][j];
                        extended[height + winSize + i][j] = extended[height + winSize - 2 - i][j];
                    }
                }
                
                for (let i = 0; i < newHeight; i++) {
                    for (let j = 0; j < winSize; j++) {
                        extended[i][winSize - 1 - j] = extended[i][winSize + 1 + j];
                        extended[i][width + winSize + j] = extended[i][width + winSize - 2 - j];
                    }
                }
                
                return extended;
            }

            getLOEPerformanceRating(loeValue) {
                if (loeValue < 50) return 'Excellent';
                if (loeValue < 100) return 'Good';
                if (loeValue < 200) return 'Fair';
                if (loeValue < 400) return 'Poor';
                return 'Very Poor';
            }
            
            getRatingColor(rating) {
                const colors = {
                    'Excellent': '#2e7d32',
                    'Good': '#388e3c',
                    'Fair': '#f57c00',
                    'Poor': '#d32f2f',
                    'Very Poor': '#c62828',
                    'No Data': '#666'
                };
                return colors[rating] || '#666';
            }

            getInterpretation(score) {
                return `LOE score of ${score.toFixed(3)} - ${this.getLOEPerformanceRating(score).toLowerCase()} enhancement quality`;
            }

            getPerformanceRating(score) {
                return this.getLOEPerformanceRating(score);
            }

            simulateDelay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        class NIQECalculator {
            constructor() {
                // NIQE implementation would go here
                // This is a placeholder for the NIQE algorithm
            }

            async calculateImageNIQE(image) {
                // Simulate NIQE calculation
                await this.simulateDelay(100);
                return Math.random() * 10 + 2; // Simulate NIQE score between 2-12
            }

            getInterpretation(score) {
                return `NIQE score of ${score.toFixed(3)} - lower values indicate more natural image quality`;
            }

            getPerformanceRating(score) {
                if (score < 3) return 'Excellent';
                if (score < 5) return 'Good';
                if (score < 7) return 'Fair';
                if (score < 10) return 'Poor';
                return 'Very Poor';
            }

            getRatingColor(rating) {
                const colors = {
                    'Excellent': '#2e7d32',
                    'Good': '#388e3c',
                    'Fair': '#f57c00',
                    'Poor': '#d32f2f',
                    'Very Poor': '#c62828'
                };
                return colors[rating] || '#666';
            }

            simulateDelay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        class ImageQualityAssessmentApp {
            constructor() {
                this.inputImage = null;
                this.enhancedImage = null;
                this.selectedDatasets = new Set();
                this.selectedMethods = new Set();
                this.selectedMetrics = new Set(['loe']); // Default to LOE
                this.batchResults = new Map();
                this.availableImages = new Set();
                this.individualScores = new Map(); // Store individual image scores for all metrics
                this.datasetSpecificImages = new Map(); // Store available images per dataset
                
                // Initialize quality metric calculators
                this.metricCalculators = {
                    loe: new LOECalculator(),
                    niqe: new NIQECalculator(),
                    // Future calculators will be added here
                };
                
                this.setupUI();
            }

            setupUI() {
                this.populateDatasetGrid();
                this.populateMethodGrid();
                this.populateMetricGrid();
                this.setupSingleImageMode();
                this.setupBatchMode();
            }

            populateDatasetGrid() {
                const grid = document.getElementById('datasetGrid');
                grid.innerHTML = '';
                
                DATASETS.forEach(dataset => {
                    const item = document.createElement('div');
                    item.className = 'checkbox-item';
                    item.innerHTML = `
                        <input type="checkbox" id="dataset-${dataset}" value="${dataset}">
                        <label for="dataset-${dataset}">${dataset}</label>
                    `;
                    
                    const checkbox = item.querySelector('input');
                    checkbox.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            this.selectedDatasets.add(dataset);
                            item.classList.add('selected');
                        } else {
                            this.selectedDatasets.delete(dataset);
                            item.classList.remove('selected');
                        }
                        this.updateBatchButton();
                    });
                    
                    grid.appendChild(item);
                });
            }

            populateMethodGrid() {
                const grid = document.getElementById('methodGrid');
                grid.innerHTML = '';
                
                METHODS.forEach(method => {
                    const item = document.createElement('div');
                    item.className = 'checkbox-item';
                    item.innerHTML = `
                        <input type="checkbox" id="method-${method.replace(/\s+/g, '-')}" value="${method}">
                        <label for="method-${method.replace(/\s+/g, '-')}">${method}</label>
                    `;
                    
                    const checkbox = item.querySelector('input');
                    checkbox.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            this.selectedMethods.add(method);
                            item.classList.add('selected');
                        } else {
                            this.selectedMethods.delete(method);
                            item.classList.remove('selected');
                        }
                        this.updateBatchButton();
                    });
                    
                    grid.appendChild(item);
                });
            }

            populateMetricGrid() {
                const grid = document.getElementById('metricGrid');
                grid.innerHTML = '';
                
                QUALITY_METRICS.forEach(metric => {
                    const item = document.createElement('div');
                    item.className = `checkbox-item ${metric.disabled ? 'disabled' : ''}`;
                    
                    const typeIcon = metric.type === 'no-reference' ? '🔍' : '🔗';
                    const statusText = metric.disabled ? ' (Coming Soon)' : '';
                    
                    item.innerHTML = `
                        <input type="checkbox" id="metric-${metric.id}" value="${metric.id}" 
                               ${metric.disabled ? 'disabled' : ''} 
                               ${metric.id === 'loe' ? 'checked' : ''}>
                        <label for="metric-${metric.id}" title="${metric.description}">
                            ${typeIcon} <strong>${metric.name}</strong>${statusText}
                            <br><small style="color: #666;">${metric.fullName}</small>
                        </label>
                    `;
                    
                    if (metric.disabled) {
                        item.style.opacity = '0.5';
                        item.style.cursor = 'not-allowed';
                    }
                    
                    const checkbox = item.querySelector('input');
                    checkbox.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            this.selectedMetrics.add(metric.id);
                            if (!metric.disabled) item.classList.add('selected');
                        } else {
                            this.selectedMetrics.delete(metric.id);
                            item.classList.remove('selected');
                        }
                        this.updateBatchButton();
                        this.updateSingleCalculateButton();
                    });
                    
                    // Select LOE by default
                    if (metric.id === 'loe') {
                        item.classList.add('selected');
                    }
                    
                    grid.appendChild(item);
                });
            }

            updateBatchButton() {
                const btn = document.getElementById('batchCalculateBtn');
                const isReady = this.selectedDatasets.size > 0 && this.selectedMethods.size > 0 && this.selectedMetrics.size > 0;
                btn.disabled = !isReady;
                
                if (isReady) {
                    const metricsText = Array.from(this.selectedMetrics).join(', ').toUpperCase();
                    btn.innerHTML = `Process ${this.selectedDatasets.size} Dataset(s) × ${this.selectedMethods.size} Method(s)<br><small style="font-size:0.8em;opacity:0.9">Metrics: ${metricsText}</small>`;
                } else {
                    btn.textContent = 'Start Batch Processing';
                }
            }

            setupSingleImageMode() {
                // File input handlers
                document.getElementById('inputFile').addEventListener('change', (e) => {
                    this.handleFileSelect(e, 'input');
                });
                document.getElementById('enhancedFile').addEventListener('change', (e) => {
                    this.handleFileSelect(e, 'enhanced');
                });

                // Drag and drop handlers
                this.setupDragAndDrop('inputUpload', 'inputFile', 'input');
                this.setupDragAndDrop('enhancedUpload', 'enhancedFile', 'enhanced');

                // Calculate button
                document.getElementById('calculateBtn').addEventListener('click', () => {
                    this.calculateSingleQualityMetrics();
                });
            }

            setupBatchMode() {
                document.getElementById('batchCalculateBtn').addEventListener('click', () => {
                    this.startBatchProcessing();
                });

                document.getElementById('imageSelector').addEventListener('change', (e) => {
                    this.showImageComparison(e.target.value);
                });
            }

            setupDragAndDrop(uploadBoxId, fileInputId, type) {
                const uploadBox = document.getElementById(uploadBoxId);
                const fileInput = document.getElementById(fileInputId);

                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadBox.addEventListener(eventName, this.preventDefaults, false);
                });

                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadBox.addEventListener(eventName, () => {
                        uploadBox.classList.add('dragover');
                    }, false);
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    uploadBox.addEventListener(eventName, () => {
                        uploadBox.classList.remove('dragover');
                    }, false);
                });

                uploadBox.addEventListener('drop', (e) => {
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        fileInput.files = files;
                        this.handleFileSelect({ target: fileInput }, type);
                    }
                }, false);
            }

            preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            handleFileSelect(event, type) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        if (type === 'input') {
                            this.inputImage = img;
                            this.showPreview(img, file, 'inputPreview');
                        } else {
                            this.enhancedImage = img;
                            this.showPreview(img, file, 'enhancedPreview');
                        }
                        this.updateSingleCalculateButton();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            showPreview(img, file, containerId) {
                const container = document.getElementById(containerId);
                container.innerHTML = `
                    <img src="${img.src}" alt="Preview" class="preview-image">
                    <div class="image-info">
                        ${file.name}<br>
                        ${img.width} × ${img.height} pixels<br>
                        <small>${(file.size / 1024).toFixed(1)} KB</small>
                    </div>
                `;
            }

            updateSingleCalculateButton() {
                const btn = document.getElementById('calculateBtn');
                const isReady = this.inputImage && this.enhancedImage && this.selectedMetrics.size > 0;
                btn.disabled = !isReady;
                
                if (isReady) {
                    const sameSize = this.inputImage.width === this.enhancedImage.width && 
                                   this.inputImage.height === this.enhancedImage.height;
                    
                    const metricsText = Array.from(this.selectedMetrics).join(', ').toUpperCase();
                    
                    if (!sameSize) {
                        btn.innerHTML = `Calculate Quality Metrics<br><small style="font-size:0.8em;opacity:0.9">Enhanced image will be resized to ${this.inputImage.width}×${this.inputImage.height}<br>Metrics: ${metricsText}</small>`;
                    } else {
                        btn.innerHTML = `Calculate Quality Metrics<br><small style="font-size:0.8em;opacity:0.9">Metrics: ${metricsText}</small>`;
                    }
                } else if (this.inputImage && this.enhancedImage) {
                    btn.innerHTML = 'Select at least one quality metric';
                } else {
                    btn.innerHTML = 'Calculate Quality Metrics';
                }
            }

            async calculateSingleQualityMetrics() {
                document.getElementById('processing').classList.add('show');
                document.getElementById('resultSection').classList.remove('show');

                try {
                    const results = {};
                    
                    // Calculate each selected metric
                    for (const metricId of this.selectedMetrics) {
                        const calculator = this.metricCalculators[metricId];
                        if (!calculator) {
                            console.warn(`Calculator for ${metricId} not available`);
                            continue;
                        }
                        
                        let score;
                        if (metricId === 'loe') {
                            score = await calculator.calculateImageLOE(this.inputImage, this.enhancedImage);
                        } else if (metricId === 'niqe') {
                            // For NIQE, we only need the enhanced image (no-reference)
                            score = await calculator.calculateImageNIQE(this.enhancedImage);
                        }
                        // Future metrics will be added here with their specific APIs
                        
                        results[metricId] = score;
                    }
                    
                    this.showSingleResults(results);
                } catch (error) {
                    console.error('Quality metric calculation error:', error);
                    alert('Error calculating quality metrics: ' + error.message);
                } finally {
                    document.getElementById('processing').classList.remove('show');
                }
            }

            async startBatchProcessing() {
                document.getElementById('batchProcessing').classList.add('show');
                document.getElementById('batchResultSection').classList.remove('show');
                document.getElementById('imageGallery').style.display = 'none';
                
                this.batchResults.clear();
                this.availableImages.clear();
                this.individualScores = new Map();
                this.datasetSpecificImages = new Map();
                
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                try {
                    // First, discover available images for selected datasets
                    const availableImages = await this.discoverAvailableImages();
                    
                    if (availableImages.length === 0) {
                        throw new Error('No images found in the selected datasets. Please check the repository structure.');
                    }
                    
                    // Calculate total operations based on dataset-specific images
                    let totalOperations = 0;
                    for (const dataset of this.selectedDatasets) {
                        const datasetImages = this.datasetSpecificImages.get(dataset) || [];
                        totalOperations += datasetImages.length * this.selectedMethods.size;
                    }
                    
                    let completedOperations = 0;
                    
                    console.log(`🚀 Starting batch processing:`);
                    console.log(`   📊 ${this.selectedDatasets.size} datasets selected`);
                    console.log(`   🔧 ${this.selectedMethods.size} methods selected`);
                    console.log(`   📏 ${this.selectedMetrics.size} metrics selected: ${Array.from(this.selectedMetrics).join(', ')}`);
                    console.log(`   🎯 ${totalOperations} total calculations`);
                    console.log(`   🌐 Loading from: https://syedaoonshah.github.io/illuminating-darkness/`);
                    console.log('');
                    
                    for (const dataset of this.selectedDatasets) {
                        if (!this.batchResults.has(dataset)) {
                            this.batchResults.set(dataset, new Map());
                        }
                        
                        const datasetImages = this.datasetSpecificImages.get(dataset) || [];
                        
                        if (datasetImages.length === 0) {
                            console.warn(`⚠️ No images found for ${dataset}, skipping...`);
                            continue;
                        }
                        
                        console.log(`\n📁 Processing ${dataset} dataset (${datasetImages.length} images)...`);
                        
                        for (const method of this.selectedMethods) {
                            progressText.textContent = `Processing ${dataset} - ${method}...`;
                            
                            const metricScores = {}; // Store scores for each metric
                            let successfulProcessing = 0;
                            
                            for (const imageName of datasetImages) {
                                try {
                                    progressText.textContent = `Processing ${dataset} - ${method} - ${imageName}`;
                                    
                                    const inputImageUrl = `https://syedaoonshah.github.io/illuminating-darkness/datasets/${dataset}/inputs/${imageName}`;
                                    const enhancedImageUrl = `https://syedaoonshah.github.io/illuminating-darkness/datasets/${dataset}/results/${method}/${imageName}`;
                                    
                                    console.log(`🔄 Processing: ${dataset}/${method}/${imageName}`);
                                    
                                    const inputImage = await this.metricCalculators.loe.loadImageFromPath(inputImageUrl);
                                    const enhancedImage = await this.metricCalculators.loe.loadImageFromPath(enhancedImageUrl);
                                    
                                    if (inputImage && enhancedImage) {
                                        // Calculate real quality metrics using selected metrics
                                        const metricResults = await this.calculateRealMetrics(inputImage, enhancedImage);
                                        
                                        // Store results for each metric
                                        for (const [metricId, score] of Object.entries(metricResults)) {
                                            if (!this.individualScores.has(dataset)) {
                                                this.individualScores.set(dataset, new Map());
                                            }
                                            if (!this.individualScores.get(dataset).has(method)) {
                                                this.individualScores.get(dataset).set(method, new Map());
                                            }
                                            if (!this.individualScores.get(dataset).get(method).has(metricId)) {
                                                this.individualScores.get(dataset).get(method).set(metricId, new Map());
                                            }
                                            this.individualScores.get(dataset).get(method).get(metricId).set(imageName, score);
                                            
                                            // Store for computing means
                                            if (!metricScores[metricId]) {
                                                metricScores[metricId] = [];
                                            }
                                            metricScores[metricId].push(score);
                                        }
                                        
                                        successfulProcessing++;
                                        
                                        const metricsText = Object.entries(metricResults)
                                            .map(([id, score]) => `${id.toUpperCase()}=${score.toFixed(3)}`)
                                            .join(', ');
                                        console.log(`   ✅ ${dataset}/${method}/${imageName}: ${metricsText}`);
                                        
                                        this.availableImages.add(imageName);
                                    } else {
                                        if (!inputImage) console.warn(`   ❌ Failed to load input: ${inputImageUrl}`);
                                        if (!enhancedImage) console.warn(`   ❌ Failed to load enhanced: ${enhancedImageUrl}`);
                                    }
                                    
                                } catch (error) {
                                    console.error(`   💥 Error processing ${dataset}/${method}/${imageName}:`, error.message);
                                }
                                
                                completedOperations++;
                                const progress = (completedOperations / totalOperations) * 100;
                                progressFill.style.width = `${progress}%`;
                                
                                await this.metricCalculators.loe.simulateDelay(50);
                            }
                            
                            // Calculate mean scores for this method on this dataset
                            const methodResults = {};
                            
                            for (const [metricId, scores] of Object.entries(metricScores)) {
                                if (scores.length > 0) {
                                    methodResults[metricId] = {
                                        scores: scores,
                                        mean: scores.reduce((sum, score) => sum + score, 0) / scores.length,
                                        processedImages: successfulProcessing,
                                        totalImages: datasetImages.length
                                    };
                                } else {
                                    methodResults[metricId] = {
                                        scores: [],
                                        mean: null,
                                        processedImages: 0,
                                        totalImages: datasetImages.length
                                    };
                                }
                            }
                            
                            this.batchResults.get(dataset).set(method, methodResults);
                            
                            if (successfulProcessing > 0) {
                                const metricsText = Object.entries(methodResults)
                                    .filter(([id, data]) => data.mean !== null)
                                    .map(([id, data]) => `${id.toUpperCase()}=${data.mean.toFixed(3)}`)
                                    .join(', ');
                                console.log(`${dataset}/${method}: ${metricsText} (${successfulProcessing}/${datasetImages.length} images)`);
                            } else {
                                console.warn(`No images processed successfully for ${dataset}/${method}`);
                            }
                        }
                    }
                    
                    progressText.textContent = 'Processing completed!';
                    this.showBatchResults();
                    
                } catch (error) {
                    console.error('Batch processing error:', error);
                    alert('Error during batch processing: ' + error.message + '\n\nPlease check the console for detailed error information.');
                } finally {
                    setTimeout(() => {
                        document.getElementById('batchProcessing').classList.remove('show');
                    }, 1000);
                }
            }

            async discoverAvailableImages() {
                const datasetImages = {
                    'NPE': ['birds.png', 'harbor.png', 'night fall.png', 'Parking.png', 'rail.png', 'road.png', 'sculpture.png', 'skyscraper.png'],
                    'MEF': ['Balloons.png', 'BelgiumHouse.png', 'Cadik.png', 'Candle.png', 'Cave.png', 'ChineseGarden.png', 'Farmhouse.png', 'House.png', 'Kluki.png', 'Lamp.png', 'Landscape.png', 'LightHouse.png', 'Madison.png', 'Memorial.png', 'Office.png', 'Tower.png', 'Venice.png'],
                    'DICM': ['01.jpg', '02.jpg', '03.jpg', '04.jpg', '05.jpg', '06.jpg', '07.jpg', '08.jpg', '09.jpg', '10.jpg', '11.jpg', '12.jpg', '13.jpg', '14.jpg', '15.jpg', '16.jpg', '17.jpg', '18.jpg', '19.jpg', '20.jpg', '21.jpg', '22.jpg', '25.jpg', '26.jpg', '27.jpg', '28.jpg', '29.jpg', '30.jpg', '31.jpg', '32.jpg', '33.jpg', '34.jpg', '35.jpg', '36.jpg', '37.jpg', '38.jpg', '39.jpg', '40.jpg', '41.jpg', '42.jpg', '43.jpg', '44.jpg', '45.jpg', '46.jpg', '47.jpg', '48.jpg', '49.jpg', '50.jpg', '52.jpg', '53.jpg', '54.jpg', '55.jpg', '56.jpg', '57.jpg', '58.jpg', '60.jpg', '61.jpg', '62.jpg', '63.jpg', '64.jpg', '65.jpg', '66.jpg', '67.jpg', '69.jpg'],
                    'LOL': ['1.png', '111.png', '146.png', '179.png', '22.png', '23.png', '493.png', '547.png', '55.png', '665.png', '669.png', '748.png', '778.png', '780.png', '79.png'],
                    'LIME': ['1.bmp', '10.bmp', '2.bmp', '3.bmp', '4.bmp', '5.bmp', '6.bmp', '7.bmp', '8.bmp', '9.bmp']
                };
                
                this.datasetSpecificImages = new Map();
                
                console.log(`🔍 Discovering images for selected datasets...`);
                
                for (const dataset of this.selectedDatasets) {
                    console.log(`\n📁 Checking ${dataset} dataset...`);
                    
                    const imagesToCheck = datasetImages[dataset];
                    
                    if (!imagesToCheck) {
                        console.warn(`   ⚠️ No predefined images for dataset: ${dataset}`);
                        continue;
                    }
                    
                    console.log(`   📋 Checking ${imagesToCheck.length} predefined images for ${dataset}...`);
                    
                    const datasetAvailableImages = [];
                    
                    for (const imageName of imagesToCheck) {
                        try {
                            const testImageUrl = `https://syedaoonshah.github.io/illuminating-darkness/datasets/${dataset}/inputs/${imageName}`;
                            const testImage = await this.metricCalculators.loe.loadImageFromPath(testImageUrl);
                            if (testImage) {
                                datasetAvailableImages.push(imageName);
                                console.log(`   ✓ Found: ${imageName}`);
                            } else {
                                console.log(`   ✗ Missing: ${imageName}`);
                            }
                        } catch (error) {
                            console.log(`   ✗ Error checking: ${imageName} - ${error.message}`);
                        }
                    }
                    
                    this.datasetSpecificImages.set(dataset, datasetAvailableImages);
                    console.log(`   📊 ${dataset}: Found ${datasetAvailableImages.length} images`);
                }
                
                console.log(`\n📊 Discovery Summary:`);
                for (const [dataset, images] of this.datasetSpecificImages) {
                    console.log(`   📁 ${dataset}: ${images.length} images - ${images.slice(0, 3).join(', ')}${images.length > 3 ? '...' : ''}`);
                }
                
                const allAvailableImages = new Set();
                for (const images of this.datasetSpecificImages.values()) {
                    images.forEach(img => allAvailableImages.add(img));
                }
                
                const combinedList = Array.from(allAvailableImages);
                console.log(`   🎯 Combined unique images: ${combinedList.length}`);
                
                return combinedList;
            }

            async calculateRealMetrics(inputImage, enhancedImage) {
                const results = {};
                
                for (const metricId of this.selectedMetrics) {
                    const calculator = this.metricCalculators[metricId];
                    if (!calculator) continue;
                    
                    try {
                        let score;
                        if (metricId === 'loe') {
                            score = await calculator.calculateImageLOE(inputImage, enhancedImage);
                        } else if (metricId === 'niqe') {
                            score = await calculator.calculateImageNIQE(enhancedImage);
                        }
                        // Future metrics will be added here
                        
                        results[metricId] = score;
                    } catch (error) {
                        console.warn(`Error calculating ${metricId}:`, error);
                    }
                }
                
                return results;
            }

            showBatchResults() {
                const content = document.getElementById('batchResultsContent');
                let html = '';
                
                // Create summary table for each dataset
                for (const [dataset, methods] of this.batchResults) {
                    html += `
                        <h4 style="margin: 25px 0 15px 0; color: #333; font-size: 1.3rem;">${dataset} Dataset Results</h4>
                        <table class="batch-results-table">
                            <thead>
                                <tr>
                                    <th>Enhancement Method</th>
                    `;
                    
                    // Add column headers for each selected metric
                    for (const metricId of this.selectedMetrics) {
                        const metric = QUALITY_METRICS.find(m => m.id === metricId);
                        const metricName = metric ? metric.name : metricId.toUpperCase();
                        html += `<th>${metricName}</th>`;
                    }
                    
                    html += `
                                    <th>Images Processed</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;
                    
                    // Sort methods by the first selected metric
                    const primaryMetricId = Array.from(this.selectedMetrics)[0];
                    const primaryMetric = QUALITY_METRICS.find(m => m.id === primaryMetricId);
                    const lowerIsBetter = primaryMetric ? primaryMetric.lowerIsBetter : true;
                    
                    const sortedMethods = Array.from(methods.entries())
                        .sort((a, b) => {
                            const aData = a[1][primaryMetricId];
                            const bData = b[1][primaryMetricId];
                            
                            if (!aData || aData.mean === null) return 1;
                            if (!bData || bData.mean === null) return -1;
                            
                            return lowerIsBetter ? aData.mean - bData.mean : bData.mean - aData.mean;
                        });
                    
                    sortedMethods.forEach(([method, methodData]) => {
                        html += `<tr><td><strong>${method}</strong></td>`;
                        
                        // Add metric values for each selected metric
                        for (const metricId of this.selectedMetrics) {
                            const metricData = methodData[metricId];
                            if (metricData && metricData.mean !== null) {
                                html += `<td class="metric-value">${metricData.mean.toFixed(3)}</td>`;
                            } else {
                                html += `<td class="metric-value na">N/A</td>`;
                            }
                        }
                        
                        // Add processed images count
                        const firstMetricData = methodData[Array.from(this.selectedMetrics)[0]];
                        const processedImages = firstMetricData ? firstMetricData.processedImages : 0;
                        const totalImages = firstMetricData ? firstMetricData.totalImages : 0;
                        html += `<td>${processedImages}/${totalImages}</td>`;
                        
                        html += `</tr>`;
                    });
                    
                    // Add best method row (only if we have valid data)
                    const validMethods = sortedMethods.filter(([method, methodData]) => {
                        const primaryMetricData = methodData[primaryMetricId];
                        return primaryMetricData && primaryMetricData.mean !== null;
                    });

                    if (validMethods.length > 0) {
                        const bestMethod = validMethods[0];
                        const bestMethodData = bestMethod[1];
                        
                        html += `
                            <tr class="mean-row">
                                <td><strong>Best Method: ${bestMethod[0]}</strong></td>
                        `;
                        
                        // Add best method's metric values
                        for (const metricId of this.selectedMetrics) {
                            const metricData = bestMethodData[metricId];
                            if (metricData && metricData.mean !== null) {
                                html += `<td class="metric-value">${metricData.mean.toFixed(3)}</td>`;
                            } else {
                                html += `<td class="metric-value na">N/A</td>`;
                            }
                        }
                        
                        // Add processed images for best method
                        const firstMetricData = bestMethodData[Array.from(this.selectedMetrics)[0]];
                        const processedImages = firstMetricData ? firstMetricData.processedImages : 0;
                        const totalImages = firstMetricData ? firstMetricData.totalImages : 0;
                        html += `<td>${processedImages}/${totalImages}</td>`;
                        
                        html += `</tr>`;
                    }
                    
                    html += `</tbody></table>`;
                }
                
                // Add cross-dataset comparison if multiple datasets selected
                if (this.selectedDatasets.size > 1) {
                    html += this.createCrossDatasetComparison();
                }
                
                // Add processing summary
                html += this.createProcessingSummary();
                
                content.innerHTML = html;
                document.getElementById('batchResultSection').classList.add('show');
                
                // Setup image gallery
                this.setupImageGallery();
            }

            createCrossDatasetComparison() {
                let html = `
                    <h4 style="margin: 35px 0 15px 0; color: #333; font-size: 1.3rem;">Cross-Dataset Performance Comparison</h4>
                    <table class="batch-results-table">
                        <thead>
                            <tr>
                                <th>Enhancement Method</th>
                `;
                
                // Add dataset columns for each selected metric
                for (const dataset of this.selectedDatasets) {
                    for (const metricId of this.selectedMetrics) {
                        const metric = QUALITY_METRICS.find(m => m.id === metricId);
                        const metricName = metric ? metric.name : metricId.toUpperCase();
                        html += `<th>${dataset}<br><small style="font-size:0.8em">${metricName}</small></th>`;
                    }
                }
                
                // Add overall average columns
                for (const metricId of this.selectedMetrics) {
                    const metric = QUALITY_METRICS.find(m => m.id === metricId);
                    const metricName = metric ? metric.name : metricId.toUpperCase();
                    html += `<th>Avg ${metricName}</th>`;
                }
                
                html += `</tr></thead><tbody>`;
                
                // Calculate overall averages for each method
                const methodAverages = new Map();
                
                for (const method of this.selectedMethods) {
                    html += `<tr><td><strong>${method}</strong></td>`;
                    
                    const methodScores = {};
                    
                    // Add dataset-specific metric values
                    for (const dataset of this.selectedDatasets) {
                        for (const metricId of this.selectedMetrics) {
                            const methodData = this.batchResults.get(dataset)?.get(method);
                            const metricData = methodData?.[metricId];
                            
                            if (metricData && metricData.mean !== null) {
                                html += `<td class="metric-value">${metricData.mean.toFixed(3)}</td>`;
                                
                                // Store for overall average calculation
                                if (!methodScores[metricId]) {
                                    methodScores[metricId] = [];
                                }
                                methodScores[metricId].push(metricData.mean);
                            } else {
                                html += `<td class="metric-value na">N/A</td>`;
                            }
                        }
                    }
                    
                    // Add overall averages for each metric
                    for (const metricId of this.selectedMetrics) {
                        const scores = methodScores[metricId] || [];
                        if (scores.length > 0) {
                            const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
                            html += `<td class="metric-value" style="background: #f0f9ff;"><strong>${average.toFixed(3)}</strong></td>`;
                            
                            // Store method averages for finding best overall method
                            if (!methodAverages.has(method)) {
                                methodAverages.set(method, {});
                            }
                            methodAverages.get(method)[metricId] = average;
                        } else {
                            html += `<td class="metric-value na">N/A</td>`;
                        }
                    }
                    
                    html += `</tr>`;
                }
                
                // Add best overall method row based on primary metric
                const primaryMetricId = Array.from(this.selectedMetrics)[0];
                const primaryMetric = QUALITY_METRICS.find(m => m.id === primaryMetricId);
                const lowerIsBetter = primaryMetric ? primaryMetric.lowerIsBetter : true;
                
                const bestOverallMethod = Array.from(methodAverages.entries())
                    .filter(([method, scores]) => scores[primaryMetricId] !== undefined)
                    .sort((a, b) => {
                        const scoreA = a[1][primaryMetricId];
                        const scoreB = b[1][primaryMetricId];
                        return lowerIsBetter ? scoreA - scoreB : scoreB - scoreA;
                    })[0];
                
                if (bestOverallMethod) {
                    html += `
                        <tr class="mean-row">
                            <td><strong>Best Overall: ${bestOverallMethod[0]}</strong></td>
                    `;
                    
                    // Add placeholder cells for dataset columns
                    for (const dataset of this.selectedDatasets) {
                        for (const metricId of this.selectedMetrics) {
                            html += `<td>-</td>`;
                        }
                    }
                    
                    // Add best method's overall averages
                    for (const metricId of this.selectedMetrics) {
                        const average = bestOverallMethod[1][metricId];
                        if (average !== undefined) {
                            html += `<td class="metric-value"><strong>${average.toFixed(3)}</strong></td>`;
                        } else {
                            html += `<td class="metric-value na">N/A</td>`;
                        }
                    }
                    
                    html += `</tr>`;
                }
                
                html += `</tbody></table>`;
                return html;
            }

            createProcessingSummary() {
                let totalImages = 0;
                let successfulProcessing = 0;
                let totalMethods = 0;
                let methodsWithData = 0;
                
                for (const [dataset, methods] of this.batchResults) {
                    for (const [method, methodData] of methods) {
                        totalMethods++;
                        const firstMetric = methodData[Array.from(this.selectedMetrics)[0]];
                        if (firstMetric) {
                            totalImages += firstMetric.totalImages;
                            successfulProcessing += firstMetric.processedImages;
                            if (firstMetric.mean !== null) methodsWithData++;
                        }
                    }
                }
                
                const successRate = totalImages > 0 ? (successfulProcessing / totalImages * 100).toFixed(1) : '0';
                const methodSuccessRate = totalMethods > 0 ? (methodsWithData / totalMethods * 100).toFixed(1) : '0';
                
                let datasetInfo = '';
                for (const dataset of this.selectedDatasets) {
                    const images = this.datasetSpecificImages.get(dataset) || [];
                    datasetInfo += `<li><strong>${dataset}:</strong> ${images.length} images (${images.slice(0, 3).join(', ')}${images.length > 3 ? '...' : ''})</li>`;
                }
                
                const metricsInfo = Array.from(this.selectedMetrics).map(id => {
                    const metric = QUALITY_METRICS.find(m => m.id === id);
                    return metric ? `${metric.name} (${metric.fullName})` : id.toUpperCase();
                }).join('<br>');
                
                return `
                    <div style="background: #e8f5e8; border-radius: 10px; padding: 20px; margin-top: 25px;">
                        <h4 style="color: #2e7d32; margin-bottom: 15px;">📊 Processing Summary</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                            <div>
                                <strong>Total Images Attempted:</strong><br>
                                <span style="font-size: 1.2em; color: #2e7d32;">${totalImages}</span>
                            </div>
                            <div>
                                <strong>Successfully Processed:</strong><br>
                                <span style="font-size: 1.2em; color: #2e7d32;">${successfulProcessing}</span>
                            </div>
                            <div>
                                <strong>Success Rate:</strong><br>
                                <span style="font-size: 1.2em; color: #2e7d32;">${successRate}%</span>
                            </div>
                            <div>
                                <strong>Methods with Data:</strong><br>
                                <span style="font-size: 1.2em; color: #2e7d32;">${methodsWithData}/${totalMethods} (${methodSuccessRate}%)</span>
                            </div>
                        </div>
                        
                        <div style="background: white; border-radius: 8px; padding: 15px; margin-top: 15px;">
                            <h5 style="color: #1976d2; margin-bottom: 10px;">📁 Dataset Image Information:</h5>
                            <ul style="margin: 0; padding-left: 20px; color: #666;">
                                ${datasetInfo}
                            </ul>
                        </div>
                        
                        <div style="background: white; border-radius: 8px; padding: 15px; margin-top: 15px;">
                            <h5 style="color: #1976d2; margin-bottom: 10px;">📏 Quality Metrics Evaluated:</h5>
                            <div style="color: #666; line-height: 1.6;">
                                ${metricsInfo}
                            </div>
                        </div>
                        
                        <p style="margin-top: 15px; font-size: 0.9em; color: #666;">
                            <strong>🧮 Algorithm:</strong> Multi-metric evaluation with precise calculations for comprehensive quality assessment.
                            <br><strong>🌐 Source:</strong> Images loaded from <code>https://syedaoonshah.github.io/illuminating-darkness/</code>
                        </p>
                    </div>
                `;
            }

            setupImageGallery() {
                const selector = document.getElementById('imageSelector');
                selector.innerHTML = '<option value="">Select an image to compare...</option>';
                
                const allImages = new Set();
                
                for (const [dataset, images] of this.datasetSpecificImages) {
                    images.forEach(imageName => {
                        allImages.add(`${dataset}:${imageName}`);
                    });
                }
                
                const sortedImages = Array.from(allImages).sort((a, b) => {
                    const [datasetA, nameA] = a.split(':');
                    const [datasetB, nameB] = b.split(':');
                    if (datasetA !== datasetB) {
                        return datasetA.localeCompare(datasetB);
                    }
                    return nameA.localeCompare(nameB);
                });
                
                let currentDataset = '';
                sortedImages.forEach(imageKey => {
                    const [dataset, imageName] = imageKey.split(':');
                    
                    if (dataset !== currentDataset) {
                        if (currentDataset !== '') {
                            const separator = document.createElement('option');
                            separator.disabled = true;
                            separator.textContent = '────────────';
                            selector.appendChild(separator);
                        }
                        
                        const header = document.createElement('option');
                        header.disabled = true;
                        header.textContent = `📁 ${dataset} Dataset`;
                        header.style.fontWeight = 'bold';
                        header.style.backgroundColor = '#f0f9ff';
                        selector.appendChild(header);
                        
                        currentDataset = dataset;
                    }
                    
                    const option = document.createElement('option');
                    option.value = imageKey;
                    option.textContent = `   ${imageName}`;
                    selector.appendChild(option);
                });
                
                console.log(`🖼️ Gallery setup: ${sortedImages.length} images from ${this.datasetSpecificImages.size} datasets`);
                document.getElementById('imageGallery').style.display = 'block';
            }

            showImageComparison(imageKey) {
                if (!imageKey) {
                    document.getElementById('galleryGrid').innerHTML = '';
                    return;
                }
                
                const gallery = document.getElementById('galleryGrid');
                gallery.innerHTML = '';
                
                const [selectedDataset, imageName] = imageKey.split(':');
                
                if (!selectedDataset || !imageName) {
                    console.error('Invalid image key:', imageKey);
                    return;
                }
                
                console.log(`🖼️ Showing comparison for ${selectedDataset}/${imageName}`);
                
                const inputItem = document.createElement('div');
                inputItem.className = 'gallery-item';
                
                const inputUrl = `https://syedaoonshah.github.io/illuminating-darkness/datasets/${selectedDataset}/inputs/${imageName}`;
                inputItem.innerHTML = `
                    <img src="${inputUrl}" alt="Input Image" 
                         onerror="this.src='https://via.placeholder.com/250x200/f0f0f0/666?text=Input+Not+Found'; this.title='${inputUrl} not found';"
                         title="Input: ${imageName}">
                    <h4>Input (${selectedDataset})</h4>
                    <div class="loe-score">Original</div>
                `;
                gallery.appendChild(inputItem);
                
                let count = 0;
                for (const method of this.selectedMethods) {
                    const methodScores = {};
                    let hasAnyScore = false;
                    
                    for (const metricId of this.selectedMetrics) {
                        const score = this.individualScores?.get(selectedDataset)?.get(method)?.get(metricId)?.get(imageName);
                        if (score !== undefined) {
                            methodScores[metricId] = score;
                            hasAnyScore = true;
                        }
                    }
                    
                    if (hasAnyScore) {
                        const item = document.createElement('div');
                        item.className = 'gallery-item';
                        
                        let scoresHtml = '';
                        for (const [metricId, score] of Object.entries(methodScores)) {
                            const metric = QUALITY_METRICS.find(m => m.id === metricId);
                            if (metric) {
                                scoresHtml += `<div class="loe-score" style="font-size: 0.85rem; margin: 2px 0; color: #2e7d32;">${metric.name}: ${score.toFixed(3)}</div>`;
                            }
                        }
                        
                        const resultUrl = `https://syedaoonshah.github.io/illuminating-darkness/datasets/${selectedDataset}/results/${method}/${imageName}`;
                        item.innerHTML = `
                            <img src="${resultUrl}" alt="${method} Result" 
                                 onerror="this.src='https://via.placeholder.com/250x200/ffebee/c62828?text=${method.replace(/\s+/g, '+')}+Not+Found'; this.title='${resultUrl} not found';"
                                 title="${method}: ${imageName}">
                            <h4>${method}</h4>
                            ${scoresHtml}
                        `;
                        gallery.appendChild(item);
                        count++;
                    } else {
                        const methodData = this.batchResults.get(selectedDataset)?.get(method);
                        if (methodData) {
                            const item = document.createElement('div');
                            item.className = 'gallery-item';
                            
                            const resultUrl = `https://syedaoonshah.github.io/illuminating-darkness/datasets/${selectedDataset}/results/${method}/${imageName}`;
                            item.innerHTML = `
                                <img src="${resultUrl}" alt="${method} Result" 
                                     onerror="this.src='https://via.placeholder.com/250x200/fff3e0/e65100?text=${method.replace(/\s+/g, '+')}+Processing'; this.title='${resultUrl} - processing or not found';"
                                     title="${method}: ${imageName}">
                                <h4>${method}</h4>
                                <div class="loe-score" style="color: #ff9800;">Processing...</div>
                            `;
                            gallery.appendChild(item);
                            count++;
                        }
                    }
                }
                
                if (count > 0 || Array.from(this.selectedMethods).length > 0) {
                    const noteItem = document.createElement('div');
                    noteItem.style.gridColumn = '1 / -1';
                    noteItem.style.textAlign = 'center';
                    noteItem.style.padding = '20px';
                    noteItem.style.color = '#666';
                    noteItem.style.background = '#f0f9ff';
                    noteItem.style.borderRadius = '10px';
                    noteItem.style.marginTop = '20px';
                    noteItem.style.border = '2px solid #e3f2fd';
                    
                    const selectedMetricsText = Array.from(this.selectedMetrics).map(id => {
                        const metric = QUALITY_METRICS.find(m => m.id === id);
                        return metric ? metric.name : id.toUpperCase();
                    }).join(', ');
                    
                    noteItem.innerHTML = `
                        <h4 style="color: #1976d2; margin-bottom: 15px;">🎯 Individual Image Quality Scores</h4>
                        <p><strong>Selected Image:</strong> <code>${selectedDataset}/${imageName}</code> | <strong>Methods Displayed:</strong> ${count} of ${this.selectedMethods.size} selected</p>
                        <p><strong>Quality Metrics:</strong> ${selectedMetricsText}</p>
                        <p><strong>Input URL:</strong> <code>${inputUrl}</code></p>
                        <p><strong>Enhanced URLs:</strong> <code>https://syedaoonshah.github.io/illuminating-darkness/datasets/${selectedDataset}/results/[METHOD]/${imageName}</code></p>
                        <div style="margin-top: 15px; padding: 15px; background: #e8f5e8; border-radius: 8px;">
                            <p style="color: #2e7d32;"><strong>✅ Each score shown is calculated specifically for this individual image pair!</strong></p>
                            <p style="margin-top: 10px; font-size: 0.9em;">All ${this.selectedMethods.size} selected enhancement methods are displayed with their individual performance across ${this.selectedMetrics.size} quality metric(s) on this specific image from the ${selectedDataset} dataset.</p>
                        </div>
                    `;
                    gallery.appendChild(noteItem);
                }
            }

            showSingleResults(results) {
                const sameSize = this.inputImage.width === this.enhancedImage.width && 
                               this.inputImage.height === this.enhancedImage.height;
                
                const resultSection = document.getElementById('resultSection');
                if (!resultSection) {
                    console.error('Result section not found');
                    return;
                }
                
                let dimensionNote = '';
                if (!sameSize) {
                    dimensionNote = `<p style="font-size:0.9em;color:#666;margin-top:15px;">
                        <strong>Note:</strong> Enhanced image was resized from ${this.enhancedImage.width}×${this.enhancedImage.height} 
                        to ${this.inputImage.width}×${this.inputImage.height} for comparison.
                    </p>`;
                }
                
                // Create results display for each metric
                let metricsHtml = '';
                for (const [metricId, score] of Object.entries(results)) {
                    const metric = QUALITY_METRICS.find(m => m.id === metricId);
                    const calculator = this.metricCalculators[metricId];
                    
                    if (metric && calculator) {
                        const interpretation = calculator.getInterpretation ? calculator.getInterpretation(score) : 'Score calculated';
                        const rating = calculator.getPerformanceRating ? calculator.getPerformanceRating(score) : 'N/A';
                        const color = calculator.getRatingColor ? calculator.getRatingColor(rating) : '#666';
                        
                        metricsHtml += `
                            <div style="background: white; border-radius: 15px; padding: 20px; margin-bottom: 20px; border-left: 4px solid ${color};">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <h3 style="color: #333; margin: 0;">${metric.name} (${metric.fullName})</h3>
                                    <div style="text-align: right;">
                                        <div style="font-size: 2rem; font-weight: bold; color: ${color};">${score.toFixed(3)}</div>
                                        <div style="font-size: 0.9rem; color: ${color}; font-weight: 600;">${rating}</div>
                                    </div>
                                </div>
                                <p style="color: #666; margin: 0; font-size: 0.95rem;">${interpretation}</p>
                                <div style="font-size: 0.8rem; color: #999; margin-top: 8px;">
                                    ${metric.type === 'no-reference' ? '🔍 No-Reference' : '🔗 Full-Reference'} • 
                                    ${metric.lowerIsBetter ? 'Lower is better' : 'Higher is better'}
                                </div>
                            </div>
                        `;
                    }
                }
                
                resultSection.innerHTML = `
                    <h3 style="text-align: center; margin-bottom: 25px; color: #333;">Quality Assessment Results</h3>
                    ${metricsHtml}
                    <p style="text-align: center; margin-top: 20px;"><strong>Analysis completed!</strong> Multiple quality metrics provide comprehensive image enhancement evaluation.</p>
                    ${dimensionNote}
                `;
                
                resultSection.classList.add('show');
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new ImageQualityAssessmentApp();
        });
    </script>
</body>
</html>
